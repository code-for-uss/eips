# ErgoFund contracts

* Author: code-for-uss, kushti
* Status: Proposed
* Created: 5-Nov-2021
* License: CC0
* Forking: not needed 

## Motivation 

Collecting funds in different contexts is needed to build common infrastructure and applications in the Ergo ecosystem. Therefore, this EIP is proposing contracts and standardized box formats for announcing crowdfunding campaigns and collecting funds.

## Overall Design

The design of the crowdfunding contracts and box templates below is centered by a seamless on-chain and off-chain code built on top of the Ergo Playgrounds, [ErgoFund scenarios via playground](https://scastie.scala-lang.org/TWlB0hncT5SdYcTax3Wj5A). 

There is an old version of ErgoFund eip [here](./eip-0018-old.md), prepared by Kushti.

## Tokens

The ErgoFund has the following types of tokens.

| Token | Issued quantity | purpose | where stored |
|---|---|---|---|
|ControlBoxNFT | 1 | Identify control box | Any  |
|SellNFT | 1 | Identify sell box | Sell box |
|Registration tokens | 100 million | Identify each campaign box | Sell box <br /> Campaign boxes |
|Campaign participant tokens | 100 million per campaign | Identify campaign and each pledge box| Capmaign box <br /> pledge boxes |

## Boxes

There are a total of 3 contracts, and each corresponds to a box-type + control box.

| Box | Quantity | Tokens | Additional registers used | Purpose | Spending transactions |
|---|---|---|---|---|---|
|Control | 1 | ControlBoxNFT | R4: Price (Long), <br /> R5: address[script] (SigmaProp) | Control price and address to pay for campaign registration | <div align="center">-</div> | 
|Sell| 1 | SellNFT <br /> Registration tokens | <div align="center">-</div> | Register a new campaign | registerCampaign, <br/> returnRegistrationToken |
|Campaign | 0 - 100 million | Registration token <br /> Campaign participant tokens | R4: Campaign description (Coll[Byte]), <br /> R5: Public key of project owner (SigmaProp), <br /> R6: Campaign deadline (Int), <br /> R7: minToRaise (Long), <br /> R8 (optional): campaign Proposal CID (Coll[Byte]) | Store campaign data and collect funds | Donate to campaign, <br /> Withdraw funds, <br /> Refund donates, <br /> Return registrationToken |
|pledge | 0 - 100 million (per campaign) | Campaign participant tokens | R4: Donate value (Long), <br /> R5: Public key of backer (SigmaProp) | Store donate value and Backer public key | Refund donate (fundraising failure) |

## Contracts

### Pledge Contract

This box can only be spent if the first input box, which is the campaign box related to this pledge. Which means the campaign has failed.
(Conditions: fund collected for the project is less than the defined minToRaise and the height of the network exceeds the fundRaisingDeadline), also, in this case, the fee of funds' returning will be deducted from the backer's fund.<br />

- Registers:
  * R4: Amount of donates [donateValue] (Long)
  * R5: The public key of backer [backerPubKey] (SigmaProp)
- Tokens:
  1. campaignParticipantToken NO: [1] <br/>
        We use this token as campaignId.

```scala
{
     val donateValue = SELF.R4[Long].get
     val backerPubKey = SELF.R5[SigmaProp].get

     val campaignId = SELF.tokens(0)._1
     val campaignBox = INPUTS(0)
     val refundBox = OUTPUTS(1)
     val fundraisingFailure = campaignBox.tokens(0)._1 == campaignRegistrationTokenId       && 
                              campaignBox.tokens(1)._1 == campaignId                        && // verify campaign id
                              refundBox.value >= donateValue + SELF.value - minFee          && // ensure full refund
                              refundBox.propositionBytes == backerPubKey.propBytes // propositionBytes of refundBox must equal to backerPubKey
     sigmaProp(fundraisingFailure)
  }
```
### Campaign Contract
There are four scenarios to spend the boxes protected by this contract.

- Registers:
  * R4: Campaign description [validCampaignDesc] (Coll[Byte])
  * R5: The public key of the project owner [projectPubKey] (SigmaProp)
  * R6: Deadline of campaign [fundRaisingDeadline] (Int)
  * R7: Minimum value needed for success campaign [minToRaise] (Long)
  * R8: The CID of campaign proposal on IPFS [campaignProposalCID] (Coll[Byte])
- Tokens:
  1. registrationToken NO: [1] <br/>
        Each campaign should buy one registrationToken from the Sell contract
  2. campaignParticipantToken NO: [This can set manually when creating each campaign] <br/>
        After donating, Backer gets this token protected in the pledge contract. In other words, we use this token as campaignId.


```scala
  {
    val selfOut = OUTPUTS(0)
    val campaignRegistrationTokenId = SELF.tokens(0)._1
    val participantToken = SELF.tokens(1)
    val campaignDesc = SELF.R4[Coll[Byte]]
    val projectPubKey = SELF.R5[SigmaProp].get
    val fundRaisingDeadline = SELF.R6[Int].get // height
    val minToRaise = SELF.R7[Long].get
    val campaignProposalCID = SELF.R8[Coll[Byte]]
    val raisedValue = SELF.value - minFee

    val preservedData = SELF.propositionBytes == selfOut.propositionBytes   &&
                        campaignDesc == selfOut.R4[Coll[Byte]]              &&
                        projectPubKey == selfOut.R5[SigmaProp].get          &&
                        fundRaisingDeadline == selfOut.R6[Int].get          &&
                        minToRaise == selfOut.R7[Long].get                  &&
                        campaignProposalCID == selfOut.R8[Coll[Byte]]

    val campaignCondditions = if (HEIGHT <= fundRaisingDeadline) {
    //  Donate to campaign:
    //  The main spending path ensures that the box can be spent in a transaction producing at least two boxes:
    //    * One of the outputs, New CampaignBox, preserves data (registers) and token of registrationToken and holds the remaining campaignParticipantTokens (campaignParticipantTokenAmount - 1). Finally, the value of this box should be increased with the amount of donation if there is at least one token left in each campaign box after donation.
    //    * The other output, PledgeBox, with the value of minErg, stores the donation amount and the PubKey of Backer. Thus this box is protected under the Pledge contract.

      val pledgeBox = OUTPUTS(1)
      val minTokenPreserved = 1L
      val donateAmount = selfOut.value - SELF.value
      selfOut.tokens(0)._1 == campaignRegistrationTokenId           &&
      selfOut.tokens(1)._1 == participantToken._1                   &&
      selfOut.tokens(1)._2 >= minTokenPreserved                     &&
      selfOut.tokens(1)._2 == participantToken._2 - 1               &&
      donateAmount >= minErg                                        &&
      preservedData                                                 &&
      pledgeBox.propositionBytes == pledgePropBytes                 &&
      pledgeBox.value == minErg                                     &&
      pledgeBox.tokens(0)._1 == participantToken._1                 &&
      pledgeBox.tokens(0)._2 == 1L                                  &&
      pledgeBox.R4[Long].get == donateAmount                        &&  // Donate value
      pledgeBox.R5[SigmaProp].isDefined                                 // Backer PubKey
    }
    else if (HEIGHT > fundRaisingDeadline && !(raisedValue == 0)) {
      if( raisedValue >= minToRaise ) {
        // Withdrawal of funds if the campaign is successful:
        //   In this scenario HEIGHT should be more than fundRaisingDeadline, and also raisedValue (SELF.value - minFee) should be more than minToRaise.
        //   The main spending path ensures that the box can be spent in a transaction producing at least two boxes:
        //     * New SellBox returns registrationToken to the Sell contract
        //     * ProjectBox returns funds to the projectPubKey (R5)
        //   The fee of transaction in this scenario must be first obtained from the campaign creator
        
        val inSellBox = INPUTS(1)
        val outProjectBox = OUTPUTS(1)
        inSellBox.tokens(0)._1 == sellNFTId                        &&
        outProjectBox.value >= raisedValue                         &&
        outProjectBox.propositionBytes == projectPubKey.propBytes
      }
      else {
        //  Funds' returning if the campaign is failed:
        //  In this scenario HEIGHT should be more than fundRaisingDeadline and raisedValue (SELF.value - minFee) should be less than minToRaise.
        //  The main spending path ensures that the box can be spent in a transaction producing at least two boxes:
        //    * One of the outputs, New CampaignBox, preserves data (registers) and token of registrationToken and holds the remaining campaignParticipantTokens (campaignParticipantTokenAmount + 1).
        //           Finally, the value of this box should be decreased with the amount of donation (donateValue R4 stored in pledge box)
        //    * BackerBox return funds to the backerPubKey (R5 of pledge box)
        //  The fee of transaction in this scenario will be deducted from the backer donation      
    
        val inPledgeBox = INPUTS(1)
        preservedData                                               &&
        inPledgeBox.propositionBytes == pledgePropBytes             &&
        selfOut.tokens(0)._1 == campaignRegistrationTokenId         &&
        selfOut.tokens(1)._1 == participantToken._1                 &&
        selfOut.tokens(1)._2 == participantToken._2 + 1             &&
        selfOut.value >= SELF.value - inPledgeBox.R4[Long].get
      }
    }
    else {
      // Return registrationToken to the Sell contract:
      //  In this scenario, HEIGHT should be more than fundRaisingDeadline, and also raisedValue (SELF.value - minFee) should be equal to zero.
      //  The main spending path ensures that the box can be spent in a transaction producing at least one boxes:
      //    * New SellBox with registrationTokens + 1 protected under sell contract
      
      val inSellBox = INPUTS(1)
      raisedValue == 0                                &&
      inSellBox.tokens(0)._1 == sellNFTId
    }
    sigmaProp(campaignCondditions)
  }
```

### Sell Contract
There are two ways to spend the boxes protected by this contract:
  * To register campaign, first, it is needed to pass `control box` as a **data input**.
- Tokens:
    1. sellNFT NO: [1] <br/>
           Sell NFT used for sell box detection
    2. crowdfunding registrationToken NO: [Manually]
```scala
  {
    val selfOut = OUTPUTS(0)
    val validNFT = selfOut.tokens(0)._1 == sellNFTId
    val tokenId = selfOut.tokens(1)._1 // token the contract is selling
    val validOutTokenId = tokenId == campaignRegistrationTokenId
    val inTokensCount = SELF.tokens(1)._2
    val outTokensCount = selfOut.tokens(1)._2
    val validScript = SELF.propositionBytes == selfOut.propositionBytes
    val validValue = selfOut.value >= SELF.value

    val inCampaignBox = INPUTS(0)
    val sellConditions = if (inCampaignBox.tokens.size == 2 && inCampaignBox.tokens(0)._1 == tokenId && inCampaignBox.tokens(0)._2 == 1){
        // Return registration token after the end of the campaign (successful or unsuccessful):
        //   The main spending path ensures that the box can be spent in a transaction producing at least one boxes also in this case raisedValue should be equal zero:
        //     * A New SellBox, preserves sellNFT token, and also puts registrationToken to the box (registrationTokenAmount + 1).
        //   The fee of transaction in this scenario must be first obtained from the campaign creator.
        
        validNFT &&
        validOutTokenId &&
        (outTokensCount == inTokensCount + 1) &&
        validScript      &&
        validValue
    }
    else {
      // Register a campaign:
      //   The main spending path ensures that the box can be spent in a transaction producing at least three boxes:
      //     So to register campaign, it is needed to pass control box as a data input
      //       * New SellBox output preserves sellNFT token and puts remaining registrationToken to the box (registrationTokenAmount - 1).
      //       * The output, New CampaignBox, with minFee value(needed registers for campaign box which is explained above) and registrationToken and campaignParticipantTokens, which are protected under campaign script.
      //       * The output, RewardBox, with the value of the price of campaign registration (controlBox.R4[Long].get) which is protected under the ErgoFund publicKey (controlBox.R5[SigmaProp].get)
      val controlBox = CONTEXT.dataInputs(0)
      // Check control box NFT
      val properControlBox = (controlBox.tokens(0)._1 == controlBoxNFTId)

      val price = controlBox.R4[Long].get
      val script = controlBox.R5[SigmaProp].get

      val validTokens = validNFT && validOutTokenId && (outTokensCount == inTokensCount - 1)

      val rewardOut = OUTPUTS(1)
      val validPayment = rewardOut.value >= price && rewardOut.propositionBytes == script.propBytes

      val campaignOut = OUTPUTS(2)
      val validCampaign = campaignOut.propositionBytes == campaignPropBytes &&
                          campaignOut.tokens.size == 2 &&
                          campaignOut.tokens(0)._1 == tokenId &&
                          campaignOut.value >= minFee &&
                          campaignOut.R4[Coll[Byte]].isDefined &&
                          campaignOut.R5[SigmaProp].isDefined &&
                          campaignOut.R6[Int].isDefined &&
                          campaignOut.R7[Long].isDefined

      properControlBox && validTokens && validScript && validPayment && validCampaign && validValue
    }
    sigmaProp(sellConditions)
  }
```

## TO-DO
* Contracts to collect funds in SigUSD and other tokens.  